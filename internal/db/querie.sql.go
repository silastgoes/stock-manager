// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: querie.sql

package db

import (
	"context"
	"database/sql"
)

const createBatche = `-- name: CreateBatche :exec
INSERT INTO batches (id, item_id, initial_quantity, current_quantity, in_transit_quantity )
VALUES (?, ?, ?, ?, ?)
`

type CreateBatcheParams struct {
	ID                string
	ItemID            sql.NullString
	InitialQuantity   int32
	CurrentQuantity   int32
	InTransitQuantity int32
}

func (q *Queries) CreateBatche(ctx context.Context, arg CreateBatcheParams) error {
	_, err := q.db.ExecContext(ctx, createBatche,
		arg.ID,
		arg.ItemID,
		arg.InitialQuantity,
		arg.CurrentQuantity,
		arg.InTransitQuantity,
	)
	return err
}

const createCategory = `-- name: CreateCategory :exec
INSERT INTO categories (id, name, description, is_perishable, is_durable, hazard_level, is_batch_retrieved, is_individual)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateCategoryParams struct {
	ID               string
	Name             string
	Description      sql.NullString
	IsPerishable     bool
	IsDurable        bool
	HazardLevel      int32
	IsBatchRetrieved bool
	IsIndividual     bool
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, createCategory,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.IsPerishable,
		arg.IsDurable,
		arg.HazardLevel,
		arg.IsBatchRetrieved,
		arg.IsIndividual,
	)
	return err
}

const createItem = `-- name: CreateItem :exec
INSERT INTO items (id, name, description, external_id, category_id, is_in_stock)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateItemParams struct {
	ID          string
	Name        string
	Description sql.NullString
	ExternalID  sql.NullString
	CategoryID  sql.NullString
	IsInStock   sql.NullBool
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) error {
	_, err := q.db.ExecContext(ctx, createItem,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ExternalID,
		arg.CategoryID,
		arg.IsInStock,
	)
	return err
}

const deleteBatche = `-- name: DeleteBatche :exec
DELETE FROM batches WHERE id = ?
`

func (q *Queries) DeleteBatche(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteBatche, id)
	return err
}

const deleteCategory = `-- name: DeleteCategory :exec
DELETE FROM categories WHERE id = ?
`

func (q *Queries) DeleteCategory(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteCategory, id)
	return err
}

const deleteItem = `-- name: DeleteItem :exec
DELETE FROM items WHERE id = ?
`

func (q *Queries) DeleteItem(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteItem, id)
	return err
}

const getCategory = `-- name: GetCategory :one
SELECT id, name, description, is_perishable, is_durable, hazard_level, is_batch_retrieved, is_individual, created_at FROM categories
WHERE id = ?
`

func (q *Queries) GetCategory(ctx context.Context, id string) (Category, error) {
	row := q.db.QueryRowContext(ctx, getCategory, id)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.IsPerishable,
		&i.IsDurable,
		&i.HazardLevel,
		&i.IsBatchRetrieved,
		&i.IsIndividual,
		&i.CreatedAt,
	)
	return i, err
}

const listCategories = `-- name: ListCategories :many
SELECT id, name, description, is_perishable, is_durable, hazard_level, is_batch_retrieved, is_individual, created_at FROM categories
`

func (q *Queries) ListCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.QueryContext(ctx, listCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IsPerishable,
			&i.IsDurable,
			&i.HazardLevel,
			&i.IsBatchRetrieved,
			&i.IsIndividual,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemBatchesStock = `-- name: ListItemBatchesStock :many
SELECT i.id, i.description, i.name, i.external_id, i.category_id, i.is_in_stock, i.expiration_date, i.created_at, SUM(b.in_transit_quantity), SUM(b.current_quantity), c.name FROM items i 
JOIN categories c ON i.category_id = c.id
RIGHT JOIN batches b ON b.item_id = i.id
WHERE c.is_individual = FALSE
`

type ListItemBatchesStockRow struct {
	ID             string
	Description    sql.NullString
	Name           string
	ExternalID     sql.NullString
	CategoryID     sql.NullString
	IsInStock      sql.NullBool
	ExpirationDate sql.NullTime
	CreatedAt      sql.NullTime
	Sum            interface{}
	Sum_2          interface{}
	Name_2         string
}

func (q *Queries) ListItemBatchesStock(ctx context.Context) ([]ListItemBatchesStockRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemBatchesStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemBatchesStockRow
	for rows.Next() {
		var i ListItemBatchesStockRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Name,
			&i.ExternalID,
			&i.CategoryID,
			&i.IsInStock,
			&i.ExpirationDate,
			&i.CreatedAt,
			&i.Sum,
			&i.Sum_2,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItems = `-- name: ListItems :many
SELECT i.id, i.description, i.name, i.external_id, i.category_id, i.is_in_stock, i.expiration_date, i.created_at, c.name FROM items i 
JOIN categories c ON i.category_id = c.id
`

type ListItemsRow struct {
	ID             string
	Description    sql.NullString
	Name           string
	ExternalID     sql.NullString
	CategoryID     sql.NullString
	IsInStock      sql.NullBool
	ExpirationDate sql.NullTime
	CreatedAt      sql.NullTime
	Name_2         string
}

func (q *Queries) ListItems(ctx context.Context) ([]ListItemsRow, error) {
	rows, err := q.db.QueryContext(ctx, listItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsRow
	for rows.Next() {
		var i ListItemsRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Name,
			&i.ExternalID,
			&i.CategoryID,
			&i.IsInStock,
			&i.ExpirationDate,
			&i.CreatedAt,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listItemsStock = `-- name: ListItemsStock :many
SELECT i.id, i.description, i.name, i.external_id, i.category_id, i.is_in_stock, i.expiration_date, i.created_at, c.name FROM items i 
JOIN categories c ON i.category_id = c.id
WHERE c.is_individual = TRUE
`

type ListItemsStockRow struct {
	ID             string
	Description    sql.NullString
	Name           string
	ExternalID     sql.NullString
	CategoryID     sql.NullString
	IsInStock      sql.NullBool
	ExpirationDate sql.NullTime
	CreatedAt      sql.NullTime
	Name_2         string
}

func (q *Queries) ListItemsStock(ctx context.Context) ([]ListItemsStockRow, error) {
	rows, err := q.db.QueryContext(ctx, listItemsStock)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListItemsStockRow
	for rows.Next() {
		var i ListItemsStockRow
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.Name,
			&i.ExternalID,
			&i.CategoryID,
			&i.IsInStock,
			&i.ExpirationDate,
			&i.CreatedAt,
			&i.Name_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBatche = `-- name: UpdateBatche :exec
UPDATE batches SET 
    id = ?,
    item_id = ?,
    initial_quantity = ?,
    current_quantity = ?,
    in_transit_quantity = ?
WHERE id = ?
`

type UpdateBatcheParams struct {
	ID                string
	ItemID            sql.NullString
	InitialQuantity   int32
	CurrentQuantity   int32
	InTransitQuantity int32
	ID_2              string
}

func (q *Queries) UpdateBatche(ctx context.Context, arg UpdateBatcheParams) error {
	_, err := q.db.ExecContext(ctx, updateBatche,
		arg.ID,
		arg.ItemID,
		arg.InitialQuantity,
		arg.CurrentQuantity,
		arg.InTransitQuantity,
		arg.ID_2,
	)
	return err
}

const updateBatcheQuantity = `-- name: UpdateBatcheQuantity :exec
UPDATE batches SET 
    current_quantity = ?,
    in_transit_quantity = ?
WHERE id = ?
`

type UpdateBatcheQuantityParams struct {
	CurrentQuantity   int32
	InTransitQuantity int32
	ID                string
}

func (q *Queries) UpdateBatcheQuantity(ctx context.Context, arg UpdateBatcheQuantityParams) error {
	_, err := q.db.ExecContext(ctx, updateBatcheQuantity, arg.CurrentQuantity, arg.InTransitQuantity, arg.ID)
	return err
}

const updateCategory = `-- name: UpdateCategory :exec
UPDATE categories SET 
    name = ?,
    description = ?,
    is_perishable = ?,
    is_durable = ?,
    hazard_level = ?,
    is_batch_retrieved = ?,
    is_individual = ?
WHERE id = ?
`

type UpdateCategoryParams struct {
	Name             string
	Description      sql.NullString
	IsPerishable     bool
	IsDurable        bool
	HazardLevel      int32
	IsBatchRetrieved bool
	IsIndividual     bool
	ID               string
}

func (q *Queries) UpdateCategory(ctx context.Context, arg UpdateCategoryParams) error {
	_, err := q.db.ExecContext(ctx, updateCategory,
		arg.Name,
		arg.Description,
		arg.IsPerishable,
		arg.IsDurable,
		arg.HazardLevel,
		arg.IsBatchRetrieved,
		arg.IsIndividual,
		arg.ID,
	)
	return err
}

const updateItem = `-- name: UpdateItem :exec
UPDATE items SET 
    id = ?,
    name = ?,
    description = ?,
    external_id = ?,
    category_id = ?,
    is_in_stock = ?
WHERE id = ?
`

type UpdateItemParams struct {
	ID          string
	Name        string
	Description sql.NullString
	ExternalID  sql.NullString
	CategoryID  sql.NullString
	IsInStock   sql.NullBool
	ID_2        string
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.ExecContext(ctx, updateItem,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.ExternalID,
		arg.CategoryID,
		arg.IsInStock,
		arg.ID_2,
	)
	return err
}

const updateItemStatus = `-- name: UpdateItemStatus :exec
UPDATE items SET 
    is_in_stock = ?
WHERE id = ?
`

type UpdateItemStatusParams struct {
	IsInStock sql.NullBool
	ID        string
}

func (q *Queries) UpdateItemStatus(ctx context.Context, arg UpdateItemStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateItemStatus, arg.IsInStock, arg.ID)
	return err
}
